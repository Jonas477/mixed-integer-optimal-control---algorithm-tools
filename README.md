# Mixed-Integer Optimal-Control - Algorithm & Tools
A framework for mixed-integer optimal control problems with total variation regularization and algorithms to solve such problems numerically. Based on the paper *Vector-Valued Integer Optimal Control with TV Regularization* by Jonas Marko, Gerd Wachsmuth (2024), available on [arxiv](https://arxiv.org/abs/2411.06856).

[![DOI](https://zenodo.org/badge/941955161.svg)](https://doi.org/10.5281/zenodo.15025947)

# Features
### Modelling & Solving mixed-integer optimal control problems
The toolbox can handle abstract mixed-integer optimal control problems, where an objective is minimized with respect to a control using its first order derivative information. The user needs to implement the objective and derivative calculation for these problems.

Contained are tools to solve ODE-constrained problems without state constraints. Constraints on the integer controls are possible. Furthermore, time-dependent PDE-constrained problems with PDEs of a special structure can be solved, more details can be found in the modelling section.

The solver is based on a trust-region method that utilizes dynamic programming approaches. Total variation regularization leads to solutions without chattering. 

Note that we have also developed an algorithm for problems that additionally have non-integer controls, which will be released in the near future.

### 2D FEM-method
Incorporated in the toolbox are functions for generating meshes, defining a finite-element discretization of the function space and assembling the relevant matrices to solve 2-dimensional PDEs. There is a function to plot solutions using the `CairoMakie` package from Julia.

# Installation
Assuming that [julia](https://julialang.org/) is installed on your machine, follow these steps:

1. Clone the repository:  
   ```sh
   git clone https://github.com/Jonas477/mixed-integer-optimal-control---algorithm-tools.git
   cd mixed-integer-optimal-control---algorithm-tools
   ```
2. Open Julia in the project directory and run:  
	```julia-repl
	julia> using Pkg
   	julia> Pkg.activate(".")
   	julia> Pkg.instantiate()
   	```

This will download and install all required packages.
# Usage
## Solver
The trust-region algorithm `TRM` solves problems given as an `AbstractObjective` (more on this type in the modelling section below). 

```julia   
function TRM(obj::AbstractObjective, par::TRM_parameters = TRM_parameters(); x0 = rand_func(obj))
```
The method is described in Chapter 5 of the aforementioned [paper](https://arxiv.org/abs/2411.06856). A problem description is given in the struct `obj`. The structure `par` contains parameters for the algorithm. There are predefined values in the struct `TRM_parameters`. The algorithm starts with an initial function `x0`, which is generated by the `rand_func` function in `HelpFunctions.jl` by default. The function `TRM` is implemented in the `multi-trust.jl` file.
#### Example

```julia-repl
julia> include("multi-trust.jl")
julia> obj = LVMObj()
julia> J = TRM(obj)
0.9398946251530471
```

There are some predefined problems given in the files `julia_opt/example_*problemname*.jl`. After including `multi-trust.jl`, these problems with suitably chosen parameter values are solved by typing `main("*problemname*")`. For more information on these problems, type `?example_*problemname*.jl`.

The solution and gradient of the objective w.r.t. the control aswell as the states (if the problem is constrained by a differential equation) may be plotted using `plot_results(obj)`. If there are states, make sure that `eval_f!(obj)` was called before so that the states are calculated.

## Modelling problems
The solver handles optimization problems given as a structure that inherits `AbstractObjective`. In the following, we will describe how to define an `AbstractObjectiveLazy` inheriting from `AbstractObjective` that has all necessary fields needed by the solver described above. Central in this definition are routines to calculate the objective of the problem and the derivative w.r.t. the control, which needs to be implemented by the user in the functions `eval_f_helper` and `eval_df_helper`. 

To define an optimization problem, follow these steps:
1. Open a new file `example_*yourexample*.jl` in the `julia_opt/` folder. Replace `*yourexample*` with some name of your example.
2. Paste the following code into the file:

	```julia
	module example_*yourexample*

	using OptBundle
	using Parameters

	export ExampleObj

	@with_kw struct ExampleObj <: AbstractObjectiveLazy{ Matrix{Float64} }
		# Problem specification: Interval and discretization, number of controls and states
		T0::Float64 = # ToDo
		T1::Float64 = # ToDo
		nt::UInt64 = # ToDo

		# Admissible control values for each control
		𝓥::Vector{Vector{Int64}} = # ToDo
		iterator = OptBundle.product_iterator(𝓥)

		# Necessary fields, do not modify
		nu::UInt64 = 0 # inactive code for later release of non-integer controls
		nv::UInt64 = length(𝓥) # Number of integer controls
		nx::UInt64 = nu + nv # Total number of controls
		tau::Float64 = (T1 - T0) / nt
		x::Matrix{Float64} = Matrix{Float64}(undef, nx, nt)
		f::Base.RefValue{Float64} = Ref(0.)
		df::Matrix{Float64} = Matrix{Float64}(undef, nx, nt)
		df_valid::Base.RefValue{Bool} = Ref(false)
		f_evals::Base.RefValue{Int} = Ref(0)
		df_evals::Base.RefValue{Int} = Ref(0)
	end

	# Need to implement objective calculation for AbstractObjectiveLazy - Object
	function OptBundle.eval_f_helper( obj::ExampleObj,  x::Matrix{Float64}, cache)
		# ToDo
	end

	# Need to implement derivative calculation for AbstractObjectiveLazy - Object
	function OptBundle.eval_df_helper( obj::ExampleObj )
		return nothing
	end

	end
	```

	You may rename `ExampleObj` in the struct to a fitting designation.
3. In your file, edit all fields and functions with `# ToDo`:
	- `T0`, `T1`: The time interval over which the problem is solved. 
	- `nt`: Number of equidistant grid points used in the discretization of [`T0`,`T1`]
	- `𝓥`: Vector containing at entry $i$ all admissible integer values of the $i$-th component of the control. As an example, if $u(t)\in\\{0,1\\}^2$, then `𝓥 = [[0,1],[0,1]]`
	- `iterator`: An iterator object containing all admissible combinations of indices in `𝓥`. If, exemplary, only $(1,0)^\top$ and $(0,1)^\top$ are admissible values for a control, the iterator may only contain the tuples `(2,1)` and `(1,2)` for `𝓥 = [[0,1],[0,1]]`. 
	There are predefined functions in `OptBundle` to generate such an iterator: 
		- `OptBundle.product_iterator(𝓥)`: Returns an iterator cycling through all tuples of indices of the ragged array `𝓥`.
		- `OptBundle.bounded_sum_iterator(𝓥,lower_bound, upper_bound)`: Returns an iterator cycling through all tuples of indices `l` of `𝓥` where the 
		sum of all values in `𝓥[i][l[i]]` is in the range `[lower_bound, upper_bound]`. Example: The constraint $\sum_{i=1}^2 u_i(t) = 1$ for all $t\in [\mathrm{T0},\mathrm{T1}]$ can be modelled using `OptBundle.bounded_sum_iterator(𝓥,1,1)`.
	- `OptBundle.eval_f_helper(obj,x,cache)`: Return the objective value for your problem  `obj` with a given control `x`, which is represented by a matrix of size `obj.nx` (number of controls) × `obj.nt` (timesteps).
	- `OptBundle.eval_df_helper(obj)`: Calculate the derivative `df` for your problem `obj` corresponding to the control `obj.x` (represented as before) and return nothing. Note that the derivative $\frac{\partial f}{\partial u}$ is represented by a function $\nabla f$ and saved as a matrix `df` of size `obj.nx`×`obj.nt`. Then, the derivative in a direction $h$ is calculated as $(\nabla f, h)_{L^2}$.

You can also define additional fields in the struct to save parameters, functions or other information on the problem used in the objective and derivative calculation. A field `y` in the struct is then called by `obj.y` in the functions `eval_f_helper`, `eval_df_helper`.

Defining a problem as above is quite involved, which is why there are abstract types allowing for an easier definition of ODE-constrained problems and certain PDE-constrained problems. It can be beneficial to use the existing examples as an orientation.

### ODE-constrained problems
The abstract type `AbstractODEObjective` inheriting from `AbstractObjectiveLazy` implements `eval_f_helper` and `eval_df_helper` for ODE-constrained problems of the structure

$$
\begin{aligned}
\text{Min}\ &\int_{\mathrm{T0}}^{\mathrm{T1}} G(t,y(t),u(t))\ \mathrm{d}t\\
\text{s.t.}\ &y'(t) = F(t,y(t),u(t))\quad\text{on }(\mathrm{T0},\mathrm{T1}) \\
			&y(\mathrm{T0}) = y_0
\end{aligned}
$$

in the file `julia_opt/ODEObjective`. Here, $u$ is the control mapping to $\mathbb{R}^{n_x}$ and $y$ mapping to $\mathbb{R}^{n_y}$ the state. The calculation of the state and its adjoint employs an explicit euler scheme, which may behave poorly if the ODE is unstable.

To define ODE-constrained problems, follow the steps of the last section with some adjustments: Instead of the code block in 2., use the following template:

```julia
module example_*yourexample*

using OptBundle, ODEObjective
using Parameters

export ExampleObj

@with_kw struct ExampleObj <: AbstractObjectiveLazy{ Matrix{Float64} }
	# Problem specification: Interval and discretization, number of controls and states
	T0::Float64 = # ToDo
	T1::Float64 = # ToDo
	nt::UInt64 = # ToDo

	# Admissible control values for each control
	𝓥::Vector{Vector{Int64}} = # ToDo
	iterator = OptBundle.product_iterator(𝓥)

	# Initial value for ODE
	state0::Vector{Float64} = # ToDo

	# Fields for ODEObjective, do not modify
	nu::UInt64 = 0 # inactive code for later release of non-integer controls
	nv::UInt64 = length(𝓥) # Number of integer Controls
	ny::UInt64 = length(state0) # Number of states
	nx::UInt64 = nu + nv # Total number of controls
	tau::Float64 = (T1 - T0) / nt
	x::Matrix{Float64} = Matrix{Float64}(undef, nx, nt)
	f::Base.RefValue{Float64} = Ref(0.)
	f_evals::Base.RefValue{Int} = Ref(0)
	df::Matrix{Float64} = Matrix{Float64}(undef, nx, nt)
	df_valid::Base.RefValue{Bool} = Ref(false)
	df_evals::Base.RefValue{Int} = Ref(0)
	state::Matrix{Float64} = Matrix{Float64}(undef, ny, nt)
	adjoint::Matrix{Float64} = Matrix{Float64}(undef, ny, nt)
end

function ODEObjective.F!( obj::ExampleObj, Fval, i, y, x )
 	# ToDo
	return nothing
end

function ODEObjective.Fy!( obj::ExampleObj, Fyval, i, y, x)
	# ToDo
	return nothing
end

function ODEObjective.Fu!( obj::ExampleObj, Fuval, i, y, x )
	# ToDo
	return nothing
end

function ODEObjective.G( obj::ExampleObj, i, y, x )
	return # ToDo
end

function ODEObjective.Gy!( obj::ExampleObj, Gyval, i, y, x )
	# ToDo
	return nothing
end

function ODEObjective.Gu!( obj::ExampleObj, Guval, i, y, x)
	# ToDo
	return nothing
end

end 
```

Then, follow step 3., additionally specifying `state0` as the initial state $y_0$ of the ODE (as a vector of the same dimension as the image of $F$). Now, instead of coding the objective and derivative evaluation at a control, six functions need to be implemented, where `i` marks the grid point $t_i = \mathrm{T0} + i\cdot \Delta t$, $y(t_i) = $`y` and $u(t_i) =$`x`:
- `ODEObjective.F!( obj::ExampleObj, Fval, i, y, x)`: Evalutation of the right hand side of the ODE `Fval`. Assign to `Fval` the value $F(t_i,y(t_i),u(t_i))\in\mathbb{R}^{\mathrm{obj.ny}}$.
- `ODEObjective.Fy!( obj::ExampleObj, Fyval, i, y, x)`: Evaluation of the Jacobian of the right hand side w.r.t. the state $y$. Assign to `Fyval` the value $\frac{\partial F}{\partial y}(t_i,y(t_i),u(t_i))\in \mathbb{R}^{\mathrm{obj.ny}\times\mathrm{obj.ny}}$. 
- `ODEObjective.Fu!( obj::ExampleObj, Fuval, i, y, x)`: Evaluation of the Jacobian of the right hand side w.r.t. the control $u$. Assign to `Fuval` the value $\frac{\partial F}{\partial u}(t_i,y(t_i),u(t_i))\in \mathbb{R}^{\mathrm{obj.ny}\times\mathrm{obj.nx}}$. 
- `ODEObjective.G( obj::ExampleObj, i, y, x )`: Returns the value of $G(t_i, y(t_i), u(t_i))$.
- `ODEObjective.Gy!( obj::ExampleObj, Gyval, i, y, x)`: Evaluation of the gradient of $G$ w.r.t. the state $y$. Assign to `Gyval` the value $\nabla_y G(t_i, y(t_i), u(t_i))\in \mathbb{R}^{\mathrm{obj.ny}}$.
- `ODEObjective.Gu!( obj::ExampleObj, Guval, i, y, x)`: Evaluation of the gradient of $G$ w.r.t. the control $u$. Assign to `Guval` the value $\nabla_u G(t_i, y(t_i), u(t_i))\in \mathbb{R}^{\mathrm{obj.nx}}$.

### PDE-constrained problems
Similarly to ODE-constrained problems, the abstract type `AbstractPDEObjective` inherits from `AbstractObjectiveLazy` and implements `eval_f_helper` and `eval_df_helper` for certain PDE-constrained problems of the structure

$$
\begin{aligned}
\text{Min}\ &\int_{\mathrm{T0}}^{\mathrm{T1}} \int_\Omega G(x,t,y(x,t),u(t)) \ \mathrm{d}x  \ \mathrm{d}t + \int_{\mathrm{T0}}^{\mathrm{T1}} G_t(t,u(t))  \ \mathrm{d}t\\
\text{s.t.}\ &\frac{\partial y}{\partial t}(x,t) + \sum_{i=1}^2\sum_{j=1}^2 a_{ij}(x) \frac{\partial^2 y}{\partial x_i\partial x_j}(x,t) + \sum_{j=1}^2 b_j(x) \frac{\partial y}{\partial x_j}(x,t) + c(x) y(x,t) = \sum_{i=1}^{n_x}f_i(x)u_i(t)\quad\text{on } \Omega\times(\mathrm{T0},\mathrm{T1})\\  
&y(x,0) = y_0(x)\quad\text{on } \Omega\\
&\nabla_x y\cdot \mathrm{n} (x,t) + g(x) y(x,t) = \alpha(x)\quad\text{on } \Gamma\times (\mathrm{T0},\mathrm{T1})
\end{aligned}
$$

in the file `julia_opt/PDEObjective`. Again, $u$ is the control. We have a space variable $x$ (note that we have used `x` as control variable in the code) and $\nabla_x y\cdot \mathrm{n}$ marks the derivative of $y$ w.r.t. $x$ in the direction of the normal $\mathrm{n}$ on the boundary of $\Omega$ given by $\partial\Omega = \Gamma$.

Follow step 1. as above. Instead of step 2., copy the following code:

```julia
module example_*yourexample*

using OptBundle, FEMBundle, PDEObjective
using Parameters, LinearAlgebra
using SparseArrays

export ExampleObj

@with_kw struct ExampleObj <: AbstractObjectiveLazy{ Matrix{Float64} }
	
	# Construct mesh using function below
	mesh = construct_mesh()
	# Designate finite element type
	fe = # ToDo

	# Quadrature order, A - Area integrals, B - boundary integrals
	QuadOrderA::Int64 = # ToDo
	QuadOrderB::Int64 = # ToDo
    
	# Problem specification: Interval and discretization, number of controls and states
	T0::Float64 = # ToDo
	T1::Float64 = # ToDo
	nt::UInt64 = # ToDo
	nu::UInt64 = # ToDo

	# Admissible control values for each control
	𝓥::Vector{Vector{Int64}} = # ToDo
	iterator = OptBundle.product_iterator(𝓥)

	h_A = # ToDo
	h_b = # ToDo
	h_c = # ToDo
	h_g = # ToDo
	h_alpha = # ToDo
	# State at t=0
	y0 = x -> # ToDo
	# Functions on right hand side
	rhs = # ToDo

	# Fields for PDEObjective, do not modify
	#------------------------------------------------------------------
	quad = quadrature_unit_triangle_area(QuadOrderA)
	bquad = edge -> quadrature_unit_triangle_bdry(edge,QuadOrderB)
	Nglobal_dofs = ndofs(fe,mesh)
	nquad = length(quad)
	nv = length(𝓥)
	nx = nu + nv
	tau::Float64 = (T1 - T0) / nt
	x::Matrix{Float64} = Matrix{Float64}(undef, nx, nt)
	state::Matrix{Float64} = Matrix{Float64}(undef, Nglobal_dofs, nt+1)
	adjoint::Matrix{Float64} = Matrix{Float64}(undef, Nglobal_dofs, nt+1)
	f::Base.RefValue{Float64} = Ref(0.)
	df::Matrix{Float64} = Matrix{Float64}(undef, nx, nt)
	df_valid::Base.RefValue{Bool} = Ref(false)
	f_evals::Base.RefValue{Int} = Ref(0)
	df_evals::Base.RefValue{Int} = Ref(0)
	#------------------------------------------------------------------

	# Assemble PDE Matrices using routines below, should not be necessary to modify them
	A = assemble_stiffness(mesh,fe,quad,bquad,h_A,h_b,h_c,h_alpha)
	M = assemble_mass(mesh,fe,quad)
	F = assemble_rhs(mesh,fe,quad,bquad,h_g,rhs,nx)	
	state0 = assemble_state0(mesh,fe,quad,M,y0)

	# Precalculations for implicit Euler, do not modify
	M_invA = calculate_M_invA(M,A)
	M_invF = calculate_M_invF(M,F)
	StateMat = spdiagm(ones(Nglobal_dofs)) +tau*M_invA
	SMatLU = lu(StateMat)
	AMatLU = lu(StateMat')
end

function construct_mesh()
	# ToDo
	return mesh
end

# Returns value of G(y,u,t) where state vector resulting from FEM is already calculated
function PDEObjective.G( obj::ExampleObj, i, u)
	return # ToDo
end

function PDEObjective.G_t( obj::ExampleObj, i, u)
	return # ToDo
end

function PDEObjective.Gy!( obj::ExampleObj, Gyval, i)
	# ToDo
	return nothing
end

function PDEObjective.Gu!( obj::ExampleObj, Guval, i)
	# ToDo
	return nothing
end

## Do not change the following routines
#-------------------------------------------------------------------------------
function assemble_stiffness(mesh,fe,quad,bquad,h_A,h_beta,h_c0,h_alpha)
	# Stiffness Matrix
	A, _ = area_integrator(mesh, fe, quad, h_A, h_beta, h_c0, nothing)
	Q, _ = bdry_integrator(mesh,fe,bquad,h_alpha,nothing)
	return A+Q
end

function assemble_mass(mesh,fe,quad)
	# Stiffness Matrix
	M, _ = area_integrator(mesh, fe, quad, nothing, nothing, 1., nothing)
	return M
end

# M⁻¹F
function calculate_M_invF(M,F)
	MM = cholesky(M)
	MinvF = zeros(Float64, size(F))
	_, cols = size(F)

	for i=1:cols
		MinvF[:,i] .= MM\F[:,i]
	end
	return MinvF
end

# M⁻¹A
function calculate_M_invA(M,A)
	MM = cholesky(M)
	MinvA = zeros(Float64, size(A))
	_, cols = size(A)
	for i=1:cols
		MinvA[:,i] .= MM\A[:,i]
	end
	return MinvA
end

# If rhs is Σ fᵢ(x)⋅uᵢ(t), evaluates the vector [f₁(x),…,fₙ(x)]
function assemble_rhs(mesh,fe,quad,bquad,h_g,f,nx)

	# Right hand side functions, every column is a function in the sum
	F = zeros(Float64, ndofs(fe,mesh), nx)
	_,G = bdry_integrator(mesh,fe,bquad,nothing, h_g)

	for i = 1:nx
		_, F[:,i] = area_integrator(mesh, fe, quad, nothing, nothing, nothing, f[i])
		F[:,i] += G
	end

	return F
end

# Value of y at t=0
function assemble_state0(mesh,fe,quad,M,y0)
	_, Y0 = area_integrator(mesh, fe, quad, nothing, nothing, nothing, y0)
	return M \ Y0
end

end 
```

Follow step 3. from before, additionally specifying the following fields:
- `fe`: A finite element type for discretization of the functions space. Right now, only Lagrange elements of order 1,2 and 3 are supported and can be chosen by typing `fe = FE_Lagrange(k)`, where `k` is the order.
- `QuadOrderA` / `QuadOrderB`: Exactness order for quadrature formula for area integrals / boundary integrals. Supported are the orders 1,...,6 for `QuadOrderA` and 1,3,5 for `QuadOrderB`.
- `h_A`, `h_b`, `h_c`: These are anonymous functions (or `nothing`) given by `h_A = x -> [a₁₁(x),a₁₂(x);a₁₂(x),a₂₂(x)]`, `h_b = x -> [b₁(x),b₂(x)]` and `h_c = x -> c(x)`, where the functions $a_{ij}$, $b_j$ and $c$ appear in

$$
\sum_{i=1}^2\sum_{j=1}^2 a_{ij}(x) \frac{\partial^2 y}{\partial x_i\partial x_j}(x,t) + \sum_{j=1}^2 b_j(x) \frac{\partial y}{\partial x_j}(x,t) + c(x) y(x,t).
$$

- `h_g`, `h_alpha`: Functions appearing in $\nabla_x y\cdot \mathrm{n} (x,t) + g(x) y(x,t) = \alpha(x)$, where `h_g = x -> g(x)`, `h_alpha = x -> α(x)` (or `nothing` if they are 0).
- `y0`: Anonymous function mapping $x$ to $y_0(x)$
- `rhs`: Vector of anonymous functions on the right hand side, i.e. `rhs = x -> [f₁(x),...,fₙₓ(x)]`, where `nx = obj.nx` and `fᵢ` is the function appearing in $\sum_{i=1}^{n_x}f_i(x)u_i(t).$

Additionally, some functions need to be implemented. Again, assume that `i` corresponds to the timestep $t_i = \mathrm{T0} + i\cdot \Delta t$ and that `x` corresponds to $u(t_i)$. It may be assumed that the state $y(x,t_i)$ is implicitly given in `obj.state[:, i]`. The entries of this vector are degrees of freedom corresponding to the finite element. Since the state is calculated for all `obj.Nglobal_dofs` degrees of freedom, the value at $x$ can be reconstructed or the whole integral can be calculated directly using the precalculated mass matrix `obj.M`.
- `construct_mesh()`: Returns a mesh over $\Omega$. Available methods on mesh generation are highlighted in the next chapter. Recommended is the following approach: Generate a mesh over a predefined domain, i.e. over $[-1,1]^2$ by `mesh = mesh_library("squareg", 1.)`. Then, refine the mesh using `mesh = refine_all_cells(mesh)` until it is "fine" enough.
- `PDEObjective.G( obj::ExampleObj, i, x)`: Returns $\int_\Omega G(x,t_i,y(x,t_i),u(t_i))\ \mathrm{d}x$. 
- `PDEObjective.G_t( obj::ExampleObj, i, x)`: Returns $G_t(t_i,u(t_i))$, i.e. the part of the objective independent of the space variable.
- `PDEObjective.Gy!( obj::ExampleObj, Gyval, i)`: Evaluation of the derivative of $\int_\Omega G(x,t,y,u)\ \mathrm{d}x$ w.r.t. the state $y$. Assign to `Gyval` a vector of dimension `obj.Nglobal_dofs` which can be interpreted as the gradient of `PDEObjective.G` w.r.t. `obj.state`.
- `PDEObjective.Gu!( obj::ExampleObj, Guval, i)`: Evaluation of the gradient of $\int_\Omega G(x,t,y,u)\ \mathrm{d}x + G_t(t,u)$ w.r.t. the control $u$. Assign to `Guval` a vector with `obj.nx` entries.

## FEM-Toolkit
In the folder `julia_opt/julia_fem/`, there are various functions and tools that may be used to solve linear second order PDEs over twodimensional domains. Specifically, the form

$$
\sum_{i=1}^2\sum_{j=1}^2 a_{ij}(x) \frac{\partial^2 y}{\partial x_i\partial x_j}(x) + \sum_{j=1}^2 b_j(x) \frac{\partial y}{\partial x_j}(x) + c(x) y(x) = f(x)\quad\text{for }x\in\Omega
$$

with a Robin boundary condition

$$
\frac{\partial y}{\partial n} + \alpha y = g\quad\text{on }\Gamma\quad\text{with }\alpha\geq 0
$$

or Dirichlet boundary condition $y=g$ on $\Gamma$ is assumed. These functionalities are bundled in `FEMBundle.jl`.

### Mesh generation
In `mesh.jl`, a struct containing information on a mesh is defined by the fields
- `mesh.p`: Vertices of the mesh, each column contains the coordinates of one vertex.
- `mesh.e`: Edges of the mesh, each column contains the index (in `p`) of the incident vertices (pos. 1-2), triangle on right (3), triangle on left (4).
- `mesh.t`: Triangles of the mesh, the first three entries of each column contain the indices (in `p`) of the incident vertices.
- `mesh.np`, `mesh.ne`, `mesh.nt`: Number of vertices, edges, triangles.
- `mesh.be`: Boundary edges of the mesh, pos 1: index of edge in `e`. pos. 2: number of the part of the boundary this edge belongs to.
- `mesh.cell_to_edge`: Incidence structure of the mesh, column i contains the indices of the edges (in edges) incident to triangle i (in `p`).
- `mesh.affine_matrix`, `mesh.affine_vector`, `mesh.affine_invmatrixT`: Contains transformation matrices and vectors to move to/from world cell.

A mesh can be generated using `init_mesh(vertices::Matrix, maxarea)`. The `vertices` of the mesh are designated using a matrix where each column contains the coordinates of a vertex. The triangles will have an area smaller than `maxarea`.

Alternatively, there are predefined meshes. These can be accessed using `mesh_library(geometry,maxarea)`, where `geometry` is one of the following strings representing a domain $\Omega$:
- `"squareg"`: $\Omega = [-1,1]^2$
- `"lshapeg"`: $\Omega = [-1,1]^2\setminus ([-1,0]\times [0,1])$
- `"regulartriangleg"`: A regular triangle with vertices on the unit circle at the angles 0°, 120°, 240°
- `"unittriangle"`: A triangle with the vertices $(0,0)$, $(1,0)$, $(0,1)$
- `"slitg"`: $[-1,1]^2$ with a slit on the right side, specifically without the triangle with vertices $(0,0)$, $(1,0)$, $(1,0.01)$

There is a method to refine all cells given by `refine_all_cells(mesh)` returning a new mesh where each cell is split into 4 triangles by placing a new vertex on each edge. If `U` is a coefficient vector on the old mesh `mesh`, the coefficient vector on the new mesh `rmesh` can be calculated by `P*U` using the prolongation operator `P` returned by `prolongation(mesh, rmesh, fe)`, where `fe` is the corresponding finite element.

It is also possible to refine the cells designated in a vector `marker` using `refine_adaptively(mesh, marker)`.

### Defining a finite element
In `FE.jl`, an abstract type `FE{T}` is defined, where `T` is the value of the shape functions. Only Lagrange elements of degrees 1,2 and 3 are implemented and can be defined by `FE_Lagrange(k)`, where `k` denotes the degree. Other elements such as Hermite elements may be added by designating all relevant functions. The available functions include:
- `ndofs( ::FE, mesh )`: Number of global degrees of freedoms on `mesh`.
- `nlocaldofs( ::FE)`: Number of local degrees of freedom (i.e. on one cell).
- `flat_dofmap(fe::FE, mesh, idx)`: Returns the information from which the connectivity matrix can be constructed (vectors with nonzero rows and columns as well as values of sparse connectivity matrix).
- `shape( fe::FE, lambda, ::Val{return_d} = Val(false), ::Val{return_H} = Val(false)) where {return_d, return_H}`: Returns as a vector the values of all local shape functions on
the reference cell evaluated at the point specified by the barycentric
coordinates `lambda[1,:]`, `lambda[2,:]`, `lambda[3,:]`. The latter can be row vectors so that the evaluation is done simultaneously at all points, and a matrix is returned. If `return_d`/`return_H` are true, the derivative and hessian are also returned.
- `dof(fe::FE,mesh, i, f)`: Evaluates global dof `i` on `mesh` at the function `f` (which is assumed to be given in usual Cartesian coordinates).
- `local_dofs(fe::FE,f)`: Evaluates local dofs at the function `f` (which is assumed to be given in barycentric coordinates with 3 outputs).
- `dirichlet_constraints(fe::FE,mesh)`: Returns a matrix containing 1 in each entry corresponding to a vertex where a dirichlet condition applies.

### Assembly
The functions `area_integrator` and `bdry_integrator` may be employed to assemble the weak form of the PDE, i.e. the stiffness matrix, the mass matrix and the load vector. 

---

```julia
area_integrator(mesh, fe::FE, quadrature, h_A, h_beta, h_c0, h_f)
```
Assembly of the contributions to the weak form coming from the area integrals. Given a finite element with a corresponding function space basis $\\{\varphi_i\\}_{i=1}^{n}$, where $n$ is the number of global degrees of freedom, `area_integrator` returns a sparse matrix $M = A + B + C$ and a vector $F$, where $A,B,C$ and $F$ are given by 
 
$$
\begin{aligned}
A_{ij} &= \int_\Omega \nabla\varphi_i(x)^\top A(x)\\nabla\varphi_j(x)\ \mathrm{d}x\\
B_{ij} &= \int_\Omega\varphi_i(x) \beta(x)\cdot \nabla\varphi_j(x)\ \mathrm{d}x\\
C_{ij} &= \int_\Omega\varphi_i(x) c_0(x)\varphi_j(x)\ \mathrm{d}x\\
F_{i} &= \int_\Omega f(x) \varphi_i(x)\ \mathrm{d}x.
\end{aligned}
$$

Here, the mapping $A$ is given by `h_A`, $\beta$ by `h_beta`, $c_0$ by `h_c0` and $f$ by `h_f`.

The functions require quadrature points on the world cell and their weights given in `quadrature`. The function `quadrature_unit_triangle_area(QuadOrderA)` returns these points in barycentric coordinates for a given exactness order `QuadOrderA` ranging from 1 to 6.

---

```julia
bdry_integrator(mesh, fe::FE, h_bdry_quadrature, h_alpha, h_g)
```

Assembly of the contributions to the weak form coming from the boundary integrals over $\Gamma = \partial\Omega$. Returns a sparse matrix $Q$ and a vector $G$ given by

$$
\begin{aligned}
Q_{ij} &= \int_\Gamma \varphi_i(s) \alpha(s)\varphi_j(s)\ \mathrm{d}s\\
G_{i} &= \int_\Gamma g(s) \varphi_i(s)\ \mathrm{d}s.
\end{aligned}
$$

Here, $\alpha$ is given by `h_alpha` and $g$ is given by `h_g`. Also requires quadrature points and weights on a given edge in `h_bdry_quadrature`. The function `quadrature_unit_triangle_bdry(edge,QuadOrderB)` returns these points in barycentric coordinates for a given `edge` and exactness order `QuadOrderB`, where 1,3 or 5 can be chosen. In practice, call `bdry_integrator` with `edge -> quadrature_unit_triangle_bdry(edge,QuadOrderB)`.

### Solving a PDE

After generating a mesh `mesh` and defining a finite element `fe`, the stiffness matrix `A` and the load `F` vector can be assembled by

```julia
A,F = area_integrator(mesh,fe,quad_area,h_A,h_beta,h_c,h_f)
Q,G = bdry_integrator(mesh,fe,quad_bdry,h_alpha,h_g)

A += Q
F += G
```

For a Robin boundary condition, the coefficient vector `Y` corresponding to the weak solution of the PDE can be calculated by `Y = A \ F`. If Dirichlet boundary conditions are assumed, the weak solution may be calculated by

```julia
D = dirichlet_constraints(fe,mesh)
O = spzeros(size(D,1),size(D,1))
# Solve saddle-point formulation
YS = [A D'; D O] \ [F;zeros(size(D,1))]

# Extract solution
Y = YS[1:ndofs(fe,mesh)]
```

There are multiple ways to plot the solution:
- save the solution as `.vtk` file using `write_vtk("Solution", mesh, Y)` and then open the file in an external program capable of visualizing the solution, e.g. [Paraview](https://www.paraview.org/)
- plot the solution directly in julia using the `CairoMakie` package by typing `plot_solution(mesh,Y,"solution")`
